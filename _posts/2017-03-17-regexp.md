--- 
layout: default_modernist
title: 正则表达式
author: 王增辉
category: knowledge
---
[原文链接](http://www.cnblogs.com/aaronjs/archive/2012/06/30/2570970.html)


## 正则表达式
>  一个正则表达式就是由普通字符（例如字符 a 到 z）以及特殊字符（称为元字符）组成的文字模式。该模式描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 

## 正则表达式可以: 
* 测试字符串的某个模式。例如，可以对一个输入字符串进行测试，看在该字符串是否存在一个电话号码模式或一个信用卡号码模式。这称为数据有效性验证 
* 替换文本。可以在文档中使用一个正则表达式来标识特定文字，然后可以全部将其删除，或者替换为别的文字 
* 根据模式匹配从字符串中提取一个子字符串。可以用来在文本或输入字段中查找特定文字 

## 正则表达式对象的方法 

* test,返回一个 Boolean 值，它指出在被查找的字符串中是否存在模式。如果存在则返回 true，否则就返回 false。 
* exec,用正则表达式模式在字符串中运行查找，并返回包含该查找结果的一个数组。 
* compile,把正则表达式编译为内部格式，从而执行得更快。 

## 正则表达式对象的属性 

* source,返回正则表达式模式的文本的复本。只读。 
* lastIndex,返回字符位置，它是被查找字符串中下一次成功匹配的开始位置。 
* 1...1...9,返回九个在模式匹配期间找到的、最近保存的部分。只读。 
* input ($_),返回执行规范表述查找的字符串。只读。 
* lastMatch ($&),返回任何正则表达式搜索过程中的最后匹配的字符。只读。 
* lastParen ($+),如果有的话，返回任何正则表达式查找过程中最后括的子匹配。只读。 
* leftContext ($`),返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符。只读。 
* rightContext ($'),返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。只读。 

## String对象一些和正则表达式相关的方法 

* match,找到一个或多个正则表达式的匹配。 
* replace,替换与正则表达式匹配的子串。 
* search,检索与正则表达式相匹配的值。 
* split,把字符串分割为字符串数组。 

## 创建正则表达式
```javascript 
var re = new RegExp();//RegExp是一个对象,和Aarray一样  
//但这样没有任何效果,需要将正则表达式的内容作为字符串传递进去  
re =new RegExp("a");//最简单的正则表达式,将匹配字母a 
re=new RegExp("a","i");//第二个参数,表示匹配时不分大小写
var re = new RegExp("a","gi");//匹配所有的a或A   
var re = /a/gi; 
``` 
> RegExp构造函数第一个参数为正则表达式的文本内容,而第一个参数则为可选项标志(标志可以组合使用) 
* g （global）    全文查找
* i （ignorCase） 忽略大小写
* m （mutiple）   多行查找

# 元字符
> 元字符是正则表达式的一部分，当我们要匹配正则表达式本身时，必须对这些元字符转义.
* ( [ { \ ^ $ | ) ? * + . 
```javascript 
var str = "?";  
var re = /?/;  
alert(re.test(str));//出错，因为？是元字符，必须转义
re = /\?/;  
alert(re.test(str));//true  
//使用RegExp构造函数与使用正则表达式字面量创建正则表达式注意点 
var str = "\?";
alert(str);//只会输出? 
var re = /\?/;//将匹配?  
alert(re.test(str));//true  
re = new RegExp("\?");//出错
re = new RegExp("\\?");//正确，将匹配？  
alert(re.test(str));//true  
```
* 既然双重转义这么不友好，所以还是用正则表达式字面量的声明方式 

## 字符组
> 简单类，反向类，范围类，组合类
* 简单类  
```javascript 
var re = /[abc123]/;//将匹配abc123这6个字符中一个  
```
* 负向类  
```javascript 
re = /[^abc]/;//将匹配除abc之外的一个字符  
```
* 范围类 
```javascript 
re = /[a-b]/;//将匹配小写a-b 26个字母 
re = /[^0-9]/;//将匹配除0-9 10个字符之处的一个字符
```  
* 组合类  
```javascript 
re = /[a-b0-9A-Z_]/;//将匹配字母，数字和下划线
```  
## 预定义类
 *  ^        匹配输入字符串的开始位置 
*  $         匹配输入字符串的结束位置
*  |         将两个匹配条件进行逻辑“或”（Or）运算
*  .         IE下[^\n]，其它[^\n\r]   匹配除换行符之外的任何一个字符 
*  \d        [0-9]                   匹配数字 
*  \D        [^0-9]                  匹配非数字字符 
*  \s        [ \n\r\t\f\x0B]         匹配一个空白字符 
*  \S        [^ \n\r\t\f\x0B]        匹配一个非空白字符 
*  \w        [a-zA-Z0-9_]            匹配字母数字和下划线 
*  \W        [^a-zA-Z0-9_]           匹配除字母数字下划线之外的字符 
## 量词
* \*     匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}。 
* \+     匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配"z"。+ 等价于 {1,}。 
* ?      匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。 
* {n}    n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 
* {n,}   n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于'o+'。'o{0,}' 则等价于 'o*'。 
* {n,m}  m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 "o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}'         等价于 'o?'。请注意在逗号和两个数之间不能有空格。 

## 贪婪量词与惰性量词 

* 用贪婪量词进行匹配时，它首先会将整会字符串当成一个匹配，如果匹配的话就退出，如果不匹配，就截去最后一个字符进行匹配，如果不匹配，继续将最后一个字符截去进行匹配，直到有匹配为止。直到现在我们遇到的量词都是贪婪量词 
* 用惰性量词进行匹配时，它首先将第一个字符当成一个匹配，如果成功则退出，如果失败，则测试前两个字符，依些增加，直到遇到合适的匹配为止 

> 惰性量词仅仅在贪婪量词后面加个"?"而已,如"a+"是贪婪匹配的,"a+?"则是惰性的
```javascript 
var str = "abc"; 
var re = /\w+/;//将匹配abc 
re = /\w+?/;//将匹配a  
```
## 预定义特殊字符
* \n      换行符 
* \r      回车符 
* \t      制表符 
* \f      换页符（Tab） 
* \cX     与X对应的控制字符 
* \b      退格符(BackSpace) 
* \v      垂直制表符 
* \0      空字符("") 

## 多行模式
```javascript
var re = /[a-z]$/;     
var str = "ab\ncdef";
alert(str.replace(re,"#"));//ab\ncde#
re =/[a-z]$/m;  
alert(str.replace(re,"#"));//a#\ncde# 
 ``` 
## 分组与非捕获性分组 
```javascript
re = /abc{2}/;//将匹配abcc 
re = /(abc){2}/;//将匹配abcabc 
//上面的分组都是捕获性分组
str = "abcabc ###";  
arr = re.exec(str);  
alert(arr[1]);//abc 
 // 非捕获性分组 (?:) 
re = /(?:abc){2}/; 
arr = re.exec(str);  
alert(arr[1]);//undefined 
``` 
## 候选（也就是所说的“或”） 
```javascript
re = /^a|bc$/;//将匹配开始位置的a或结束位置的bc  
str ="add";  
alert(re.test(str));//true  
re = /^(a|bc)$/;//将匹配a或bc  
str ="bc";  
alert(re.test(str));//true  
```
## 反向引用
> 当包含分组的正则表达式进行过test,match,search这些方法之后，每个分组都被放在一个特殊的地方以备将来使用，这些存储是分组中的特殊值，我们称之为反向引用 

```javascript
var re = /(A?(B?(C?)))/;  
/*上面的正则表达式将依次产生三个分组 
(A?(B?(C?))) 最外面的 
(B?(C?)) 
(C?)*/  
str = "ABC";  
re.test(str);//反向引用被存储在RegExp对象的静态属性中  
alert(RegExp.$1+"\n"+RegExp.$2+"\n"+RegExp.$3);  
//反向引用也可以在正则表达式中使用\1 ,\2...这类的形式使用  
re = /\d+(\D)\d+\1\d+/;  
str = "2008-1-1";  
alert(re.test(str));//true  
str = "2008-4_3";  
alert(re.test(str));//false 
``` 
> 使用反向引用可以要求字符串中某几个位置上的字符必须相同.另外，在replace这类方法中可用特殊字符序列来表示反向引用 

```javascript
re = /(\d)\s(\d)/;  
str = "1234 5678";  
alert(str.replace(re,"221"));//在这个里面1表示第一个分组1234,1表示第一个分组1234,2则表示5678  
```

## 正向前瞻

> 用来捕获出现在特定字符之前的字符,只有当字符后面跟着某个特定字符才去捕获它。与正向前瞻对应的有负向前瞻，它用匹配只有当字符后面不跟着某个特定字符时才去匹配它。在执行前瞻和负向前瞻之类的运算时，正则表达式引擎会留意字符串后面的部分，然而却不移动index 

```javascript
//正向前瞻  
re = /([a-z]+(?=\d))/i;  //我们要匹配后面跟一个数字的单词，然后将单词返回，而不要返回数字  
str = "abc every1 abc";  
alert(re.test(str));//true  
alert(RegExp.$1);//every  
alert(re.lastIndex);//使用前瞻的好处是,前瞻的内容(?=\d)并不会当成一次匹配，下次匹配仍从它开始  
//负向前瞻(?!)  
re = /([a-z](?!\d))/;i  
//将匹配后面不包含数字的字母,并且不会返回(?!\d)中的内容  
str = "abc1 one";  
alert(re.test(str));  
alert(RegExp.$1);//one  
```


